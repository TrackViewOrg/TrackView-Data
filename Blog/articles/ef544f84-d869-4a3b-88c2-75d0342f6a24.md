# The Aero Update

## Phase 4: Unlocking Invisible Speed

We are entering the final straight. With the successful stress testing of the data ingestion pipeline behind us, *ApexView Telemetry* is officially moving into **Closed Beta Stage 4**.

While v3.0 focused on mechanical grip and suspension, Stage 4 introduces the "Vortex" moduleâ€”our new real-time aerodynamic mapper. In sim racing, aero is often a black box; you change a wing angle and hope for the best. We are changing that. We have built a system that reverse-engineers the drag and lift coefficients from telemetry data to build a live 3D aero-map of your car.

This update is now live on the `nightly-build` branch for all Tier 2 backers.

Here is the technical breakdown of the new aero solver, the math behind the maps, and what we need you to verify.

---

## ðŸŒªï¸ The "Vortex" Solver

Previous versions of ApexView calculated drag simply by looking at straight-line deceleration. The new Vortex solver accounts for wind direction (where supported), air density, and most importantly, dynamic ride height changes (rake) mid-corner.

### The New Aero Packet Structure

To support this, we have expanded the telemetry vector to include calculated air density and yaw angles. Below is the C++ struct for the new Aero frame. We are using `float` instead of `double` here to keep the packet size small, as aero data is inherently noisy and doesn't require double-precision.

```cpp
// ApexView v3.1 UDP Packet - Aerodynamics Block (Draft)
struct AeroDataPacket {
    uint32_t frameIdentifier;
    
    // Environmental calculation
    float airDensity;           // kg/m^3 calculated from track temp & pressure
    float headwindComponent;    // m/s (negative values indicate tailwind)
    
    // Dynamic State
    float frontRideHeightMM;    // Averaged FL/FR for rake calc
    float rearRideHeightMM;     // Averaged RL/RR for rake calc
    float yawAngleRadians;      // Slip angle relative to airflow
    
    // Calculated Forces
    float instantaneousDragN;   // Drag in Newtons
    float instantaneousDownforceN; // Downforce in Newtons
    float aeroBalancePercent;   // Front % (e.g., 42.5)

    void Serialize(Buffer& buffer) {
        buffer.write(frameIdentifier);
        buffer.write(airDensity);
        buffer.write(frontRideHeightMM);
        // ... bit-packing logic for network transmission
    }
};

```

If you notice `airDensity` returning `0.0` or `NaN` in older titles (e.g., rFactor 1 based sims), please flag this in the Discord. We may need a fallback constant for sims that don't export barometric pressure.

---

## âœˆï¸ Feature Spotlight: Dynamic Rake Sensitivity

The killer feature of Stage 4 is the **Rake Map**. This visualization plots your Downforce Coefficient () against your Front and Rear Ride Heights.

Many modern GT3 cars are "pitch sensitive"â€”if the nose dives too much under braking, you might actually *lose* rear downforce, causing instability.

### The Math Behind The Map

We calculate the effective Coefficient of Lift () in real-time using the standard aerodynamic equation, rearranged to solve for the coefficient:

Where:

*  is the Downforce (Lift) in Newtons.
*  is the Air Density ().
*  is the velocity relative to the air ().
*  is the frontal reference area ().

**What to test:** Take a high-downforce car (like the Red Bull X2019 or a modern F1 car) to a track with a massive straight (Monza or Fuji). Do a run with minimum wing, and a run with maximum wing. Check the "Aero Efficiency" scatter plot. We need to verify that the  scaling is accurate above 300 kph.

---

## ðŸ“Š Performance Metrics: Solver Latency

Calculating aero maps in real-time is CPU intensive. We switched the solver from a Python background thread to a compiled C++ worker module.

Benchmarks performed on an AMD Ryzen 5 5600X.

| Metric | Python Solver (Alpha Build) | C++ Worker (Beta Stage 4) | Improvement |
| --- | --- | --- | --- |
| **Calculation Latency** | 12ms per frame | 0.8ms per frame | **15x Faster** |
| **Map Generation Time** | 4.5s (post-stint) | Real-time | **Instant** |
| **CPU Thread Usage** | 18% | 2% | **-89%** |
| **Memory Footprint** | 400 MB | 65 MB | **-83%** |

> "We want users to see the aero balance shift *as* they hit the brakes, not 5 seconds later. The C++ worker allows us to update the graph at 60Hz without stutter." â€” *Marcus Chen, Lead Systems Architect*

---

## ðŸ–¥ Supported Platforms Status (Aero Update)

Focus testing on titles where wind simulation is active.

* **iRacing:** ðŸŸ¢ **Stable**. The new Tempest weather system is fully supported. Wind direction is accurate.
* **Assetto Corsa Competizione:** ðŸŸ¢ **Stable**. Aero map successfully detects the "porpoising" on the Ferrari 296.
* **Le Mans Ultimate:** ðŸŸ¡ **Needs Testing**. We are reading the shared memory, but the Hypercar ERS deployment sometimes desyncs the speed calculations, messing up drag estimation.
* **Richard Burns Rally (Simufy):** ðŸ”´ **Broken**. The plugin crashes when the car is airborne for more than 2 seconds.

---

## ðŸ“‹ The Testing Protocol: The Porpoising Test

We need to verify our "stall" detection logic.

1. **Car Selection:** Pick a ground-effect car (Mercedes W13 in iRacing or similar).
2. **Setup:** Lower the ride height to the absolute minimum until the car bounces (porpoises) on the straights.
3. **Observation:** Watch the "Downforce" graph. You should see a sawtooth wave pattern where downforce climbs, then instantly drops to near zero as the floor hits the track.
4. **Goal:** Ensure the "Stall Warning" indicator lights up red in the UI exactly when the downforce drops.